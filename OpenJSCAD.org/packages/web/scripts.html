<!DOCTYPE html>
<html>
<!--

== OpenJSCAD.org, Copyright (c) 2016-2017, Licensed under MIT License ==
   in conjunction with other libraries by various authors (see the individual files)

Purpose:
Choose a .jscad then uses as volume() into another .jscad
-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
  <title>gilboo.net charge volume et script jscad</title>
  <link rel="stylesheet" href="min_scripts.css" type="text/css">
  <script src="dist/min_scripts.js"></script>
	<script src="pdfkit.standalone.js"></script>
	<script src="blob-stream.js"></script>
<style>
</style>
</head>

<body>

<!-- setup display of the errors as required by OpenJSCAD.js -->
  <div class="jscad-container">
    <div id="header">
      <div id="errordiv"></div>
    </div>

<!-- setup display of the viewer, i.e. canvas -->
    <!--div oncontextmenu="return false;" id="viewerContext" design-url="carton.num/tranches01.jscad"></div-->
    <div oncontextmenu="return false;" id="viewerContext" ></div>

<!-- setup display of the status, as required by OpenJSCAD.js -->
<!-- set display: block to display this -->
    <div id="tail" style="display: block;">
      <div id="statusdiv"></div>
    </div>
  </div>

  <div id="gdscripts"><!-- GD: interface pour scripts.html -->
    <span id="titreVolume">Volume:</span>
	  <input id="fichier" type="file" accept=".jscad, .stl, .obj" />
	  <select id="selectVolume">
  		<option selected disabled>(choisir volume)</option>
  	</select>
  	<select id="selectScript">
		  <option selected disabled>(choisir script)</option>
		  <option id="calc_dimensions">Dimensions</option>
		  <option id="calc_tranches01">Tranchage / 1 axe</option>
		  <option id="calc_tranches02">Tranchage / 2 axes</option>
		  <option id="calc_facettes01">D&eacute;pliage</option>
	  </select>
	  <button id="calc_pdf">Cr&eacute;er PDF</button>
  </div>

	<textarea id="zc_facettes01" style="display:none;">
<!--
/***************************************
 * DEPLIAGE v7 modele OBJ avec groupes *
 ***************************************/
const gep_bord = 0.05, gPrec = 0.01, gPCNumVoisin = 0.7, gEchPDF = 2.8;
const vXp_NON_PRESENT = 0, vXp_SEPARE = 1, vXp_LIE = 10, vXp_LIE_COPLANAIRE = 11;
var _num = [], _nb = [], gLAff = [], _gTextScale = 0.25, gTaillePage;

function getParameterDefinitions() {
  return [
    { name: 'triangle', type: 'text', initial:'0', caption: 'Depart(s):' },
    { name: 'angle', type: 'text', initial:'0', caption: 'angle(s):' },
    { name: 'echelle', type: 'number', initial:'5', caption: 'Echelle:' },
    { name: 'echTexte', type: 'number', initial:'0.5', caption: 'Taille txt:' },
    { name: 'mode', type: 'text', initial:'prod', caption:'Mode:'},
    { name: 'format', type: 'text', initial:'A3', caption:'Format:'}
  ];
}
function angle(cx, cy, ex, ey) {
  var dy = ey - cy;
  var dx = ex - cx;
  var theta = Math.atan2(dy, dx); // range (-PI, PI]
  theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
  //if (theta < 0) theta = 360 + theta; // range [0, 360)
  return theta;
}
function mod(n, m) {
  return ((n % m) + m) % m;
}
function chercheVoisin(tab, n, nV){
  let v1 = tab[n][nV];
  let v2 = tab[n][(nV+1) % 3];
return tab.findIndex(function(el, i){return (i!== n) && el.includes(v1) && el.includes(v2)});
}
function estCoplanaire(p1, p2){
  pn1 = p1.plane.normal;
  pn2 = p2.plane.normal;
  return pn1.distanceTo(pn2) < 0.075;
}
function volumeScale(v, s){
  v.vertices = v.vertices.map(el=>el.map(x=>x * s));
  v.faceCsg = v.faces.map(m => CSG.Polygon.createFromPoints(m.map(n => v.vertices[n])));
  v.csg = CSG.fromPolygons(v.faceCsg);
  return v;
}
function main(params){
  // A: { csg, lPts, cag, V}
  /* T : { cag, v0p, v1p, v2p }
    	valeurs possible pour vXp :
	- 0		= non présent
	- 1		= separe avec n° affiche	AFFICHER n°
	----------------------------------------------
	- 10	= attache                 NE PAS AFFICHER n°
	- 11	= attache coplanaire
	- 12	= separe sans n° affiche
	*/
  utils();
  //volume();
  let a = obj();
  if(params.echelle != 1){
    a = volumeScale(a, params.echelle);
  }
  switch(params.format){
    case 'a4':
    case'A4':
      gTaillePage = {y:(210*1)-10, x:(297*1)-10};
      break;
    case 'a3':
    case 'A3':
      gTaillePage = {y:(297*1)-10, x:(210*2)-10};
      break;
    case 'a2':
    case 'A2':
      gTaillePage = {y:(210*2)-10, x:(297*2)-10};
      break;
    case 'a1':
    case 'A1':
      gTaillePage = {y:(297*2)-10, x:(210*4)-10};
      break;
    case 'a0':
    case 'A0':
      gTaillePage = {y:(210*4)-10, x:(297*4)-10};
      break;
    default:
      //gTaillePage = {y:(260*1)-10, x:(400*1)-10}; // custom
      gTaillePage = {y:(210*1)-10, x:(297*1)-10};
  }
  
  a.cag = []; // chaque triangle en 2D (calcule quand pose ou lie)
  a.lTPage = []; // liste des triangles de chaque page
  a.cumul = []; // cumul (cag) des triangles de chaque page
  a.T = [];
  a.lKO = [];
  // ,[]
  a.npl = [
  ];

  // RechercheVoisins + coplanaire + sens
  a.V = a.faces.map(function (el, iFace){return el.map(
            function (el2, iVoisin){
    let nV = chercheVoisin(a.faces, iFace, iVoisin);
    return {T: nV, n1: null, n2: null,
            estCoP: estCoplanaire(a.faceCsg[iFace], a.faceCsg[nV]), 
            sens: classify(a.faceCsg[iFace], a.faceCsg[nV])
    }; }); });
    
  // Renseigne n1/n2
  for(let i =0; i< a.V.length; i++){
    for(let j =0; j< a.V[i].length; j++){
        let n = a.faces[a.V[i][j].T].indexOf(a.faces[i][j]);
        a.V[i][j].n2 = n;
        a.V[i][j].n1 = mod(n-1, 3);
    }
}
  
  let nTriangles = a.V.length, r = {cag:[], pdf:[]}, nPage = 0;
  let xD;
  let prems = params.triangle.split(',').map(Number);
  let pangles = params.angle.split(',').map(Number);
  _gTextScale = params.echTexte;
  do{ // Dépliage
    xD = (prems.length > 0) ? prems.shift() : 0;
    xDa = (pangles.length > 0) ? pangles.shift() : 0;
    while(gLAff.indexOf(xD) > -1){// Rech. prochain triangle
      xD++;
    }
    let lT = depliePage(a, xD, xDa);
    a.lTPage.push(lT);
    let R = {cag: [], pdf: []};
    for(let i = 0; i < lT.length; i++){
      let tmp = afficheTriangle(a, lT[i]);
      R.cag.push(tmp.cag);
      R.pdf.push(tmp.pdf);
    } 
    if(params.mode == 'dev'){
      r.cag.push(R.cag.flat()); 
      r.pdf.push(R.pdf.flat());
    }
    else{
      r.cag.push(utils.flatNonRec(R.cag));
      r.pdf.push(utils.flatNonRec(R.pdf));
    }
  }while(gLAff.length < nTriangles);

  let tmp = trieEtAjuste(a.cumul, r.cag, r.pdf);
  a.cumul = tmp.a;
  r.cag = tmp.b;
  r.pdf = tmp.c;
  //console.log('# nb Pages brutes:', r.length);

  if(a.cumul.length > 2){
    do{ // regroupements en Y
      let dern1 = a.cumul.length-1;
      let t1 = a.cumul[dern1];
      let dern2 = dern1 -1;
      if(dern2 >= 0){
      let t2 = a.cumul[dern2];
      let hypY = utils.getTaille(t1).y + utils.getTaille(t2).y;
      if(hypY < gTaillePage.y - 0.5){
      try{
        let b1 = t1.getBounds();
        let b2 = t2.getBounds();
        let delta = new CSG.Vector2D(b2[1].x+0.5 - b1[1].x, b2[1].y - b1[0].y + 0.5);
        r.cag[dern1] = deplaceTriangle(r.cag[dern1], delta);
        r.pdf[dern1] = deplacePDF(r.pdf[dern1], delta);
        a.cumul[dern1] = a.cumul[dern1].translate(delta);
        r.cag[dern2] = r.cag[dern2].concat(r.cag.pop());
        r.pdf[dern2] = r.pdf[dern2].concat(r.pdf.pop());
        a.cumul[dern2] = a.cumul[dern2].union(a.cumul.pop());
      }catch(e){}

        let tmp = trieEtAjuste(a.cumul, r.cag, r.pdf);
        a.cumul = tmp.a;
        r.cag = tmp.b;
        r.pdf = tmp.c;
        ok = true;
      }else{
        ok = false;
      }
      }else{ ok = false;}
    }while(ok);
    
    do{ // regroupements en X
      let dern1 = a.cumul.length-1;
      let t1 = a.cumul[dern1];
      let dern2 = dern1 -1;
      if(dern2 >= 0){
      let t2 = a.cumul[dern2];
      let hypX = utils.getTaille(t1).x + utils.getTaille(t2).x;
      if(hypX < gTaillePage.x - 0.5){
        let b1 = t1.getBounds();
        let b2 = t2.getBounds();
        let delta = new CSG.Vector2D(b2[1].x - b1[0].x + 0.5, 0);
        r.cag[dern1] = deplaceTriangle(r.cag[dern1], delta);
        r.pdf[dern1] = deplacePDF(r.pdf[dern1], delta);
        a.cumul[dern1] = a.cumul[dern1].translate(delta);
        r.cag[dern2] = r.cag[dern2].concat(r.cag.pop());
        r.pdf[dern2] = r.pdf[dern2].concat(r.pdf.pop());
        a.cumul[dern2] = a.cumul[dern2].union(a.cumul.pop());
      
        let tmp = trieEtAjuste(a.cumul, r.cag, r.pdf);
        a.cumul = tmp.a;
        r.cag = tmp.b;
        r.pdf = tmp.c;
        ok = true;
      }else{
        ok = false;
      }
      }else{ ok = false;}
    }while(ok);    
  }
  
  let sortie = [];
  for(let i = 0; i < r.pdf.length; i++){
    sortie.push(exportePDF(a, r.pdf[i]));
    if(i < r.pdf.length-1){ sortie.push('page'); }
  }
  sortie.push('fin');
  
  sortie = utils.flatNonRec(sortie);
  var lEaSupprimer = [], lTaDeplacer = [], lCoords = [], lTaGriser = [];
  // simplification si T1 et T2 ont une seule encoche
// recherche des T avec 1 seul voisin
  tmpSortie = sortie.map(el => {
    let sh = el.split(' ');
    let n = Number(sh[1]);
    if(sh[0] == 'textT'){
      let nvl = a.T[n].filter(el => el != 10);
      if(nvl.length == 1){
        let iv = a.T[n].findIndex(el => el != 10);
        let nv = Number(a.V[n][iv].T);
        let nvlv = a.T[nv].filter(el => el != 10);
        if(([1,2].indexOf(nvlv.length) != -1) && (!lEaSupprimer.find(el => el.e == n))){          
          if(nvlv.length == 1)
            lTaGriser.push(nv);
          lEaSupprimer.push({t:n, e:nv});
          lTaDeplacer.push(n);
        }
        return el;
      }
    }
    return el;
  });
  
  // simplifier
  tmpSortie = tmpSortie.reduce( (acc, el) => {
    let sh = el.split(' ');
    let n = Number(sh[1]);
    if((sh[0] == 'textE') && (lEaSupprimer.find(el => 
        (el.e === n) && (el.t === Number(sh[4]))))){
      lCoords.push({t:Number(sh[4]), e:n, x:sh[2], y:sh[3], a:sh[5]});
      return acc;
    }
    if((sh[0] == 'textT') && (lTaGriser.includes(n))){
      acc.push('textt ' + sh[1] + ' ' + sh[2] + ' '+ sh[3] + ' ' + sh[4] + ' ' + sh[5]);
      return acc;
    }
    acc.push(el);
    return acc;
  }, []);
  
  // déplacer
  tmpSortie = tmpSortie.map(el => {
    let sh = el.split(' ');
    let n = Number(sh[1]);
    if((sh[0] == 'textT') && (lTaDeplacer.includes(n))){
        let iv = a.T[n].findIndex(el => el != 10);
        let nv = Number(a.V[n][iv].T);
        let c = lCoords.find(el => (el.t === n) && (el.e === nv));
        //return sh[0] + ' ' + sh[1] + ' ' + c.x + ' '+ c.y + ' ' + sh[4] + ' ' + c.a;
        return 'textTE' + ' ' + sh[1] + ' ' + c.x + ' '+ c.y + ' ' + sh[4] + ' ' + c.a;
    }
    return el;
  });

  sortie = tmpSortie.join('\n');
  
  localStorage.setItem("fc1_data", sortie);
  localStorage.setItem("fc1_x", gTaillePage.x);
  localStorage.setItem("fc1_y", gTaillePage.y);
  localStorage.setItem("fc1_tt", params.echTexte);

  if(params.mode == 'dev'){
    console.log('# nb Pages:', r.cag.length);
    return r.cag.flat();
  }
  else{
    console.log(sortie);
    return a.csg;
  }
}
function exportePDF(a, pdf){
  let retour = [], t, P1, P2, petit, grand, delta;

  // met à l'échelle
  for(let i = 0; i < pdf.length; i++){
    pdf[i].p1 = pdf[i].p1.times(gEchPDF);
    var estPt = ['L','D','M'].indexOf(pdf[i].type) > -1;
    if(estPt && (pdf[i].p2 !== null)){
      pdf[i].p2 = pdf[i].p2.times(gEchPDF);
    }
  }
  // recherche le plus grand y
  grand = {x:-10000000, y:-10000000};
  for(let i = 0; i < pdf.length; i++){
    if(pdf[i].p1.y > grand.y){ grand.y = pdf[i].p1.y;}
  }
  delta = new CSG.Vector2D(0, grand.y);
  // tourne les points à 180°
  for(let i = 0; i < pdf.length; i++){
    var estPt = ['L','D','M'].indexOf(pdf[i].type) > -1;    
    pdf[i].p1 = new CSG.Vector2D(pdf[i].p1.x, grand.y - pdf[i].p1.y)
    if(estPt && (pdf[i].p2 !== null)){
      pdf[i].p2 = new CSG.Vector2D(pdf[i].p2.x,  grand.y - pdf[i].p2.y);
    }
  }
  
  petit = {x:10000000, y:10000000};
  grand = {x:-10000000, y:-10000000};
  for(let i = 0; i < pdf.length; i++){
    P1 = pdf[i].p1;
    P2 = pdf[i].p2;
    var estPt = ['L','D','M'].indexOf(pdf[i].type) > -1;
    
    if(P1.x > grand.x){ grand.x = P1.x; }
    if(P1.y > grand.y){ grand.y = P1.y; }
    
    if(P1.x < petit.x){ petit.x = P1.x; }
    if(P1.y < petit.y){ petit.y = P1.y; }
    if(estPt && (P2 !== null)){    
      if(P2.x > grand.x){ grand.x = P2.x; }
      if(P2.y > grand.y){ grand.y = P2.y; }
      if(P2.x < petit.x){ petit.x = P2.x; }
      if(P2.y < petit.y){ petit.y = P2.y; }
    }
  }
  delta = new CSG.Vector2D(petit.x, petit.y);
  for (let i = 0; i < pdf.length; i++){
    pdf[i].p1 = pdf[i].p1.minus(delta);
    var estPt = ['L','D','M'].indexOf(pdf[i].type) > -1;
    if(estPt && (pdf[i].p2 !== null)){
      pdf[i].p2 = pdf[i].p2.minus(delta);
    }
  }
  // tri par type
  pdf = pdf.sort((a,b) => {return a.type < b.type ? -1 : 1;});

  for(let i = 0; i< pdf.length; i++){
    switch(pdf[i].type){
      case 'L': // bord
      case 'D': // pli vallee
      case 'M': // pli montagne
        if(pdf[i].type == 'L'){
          t = 'line';
        }else if(pdf[i].type == 'D'){
          t = 'dash';
        }else{
          t = 'mont'
        };
        //recherche doublon
        //let tmpch1 = ' ' + pdf[i].p1.x.toFixed(2) + ' ' + pdf[i].p1.y.toFixed(2);
        //let tmpch2 = ' ' + pdf[i].p2.x.toFixed(2) + ' ' + pdf[i].p2.y.toFixed(2);
        let tmp1ch1 = ' ' + pdf[i].p1.x.toFixed(1) + ' ' + pdf[i].p1.y.toFixed(1);
        let tmp1ch2 = ' ' + pdf[i].p2.x.toFixed(1) + ' ' + pdf[i].p2.y.toFixed(1);
        if(!retour.includes(t + tmp1ch2 + tmp1ch1 + ' ' + pdf[i].texte)){
          retour.push(t + tmp1ch1 + tmp1ch2+' ' + pdf[i].texte);
        }
        break;

      case 'T':
      case 't':
        if(pdf[i].type == 't'){t = 'textE';}
        else{
          let naf = 0;
          let voisins = a.T[Number(pdf[i].texte)];
          for(let vi = 0; vi < voisins.length; vi++){
            if(voisins[vi] == vXp_LIE)naf++;
          }
          t = (naf < 3) ? 'textT' : 'textt';
        }
        retour.push(t
          + ' ' + pdf[i].texte
          + ' ' + pdf[i].p1.x.toFixed(2) 
          + ' ' + pdf[i].p1.y.toFixed(2)
          + ' ' + pdf[i].extra
          + ' ' + pdf[i].p2.toFixed(2)
          );
        break;

      case 'P':
        retour.push('page');
        break;
    }
  }

  return retour;
}
function pushPDF(ltype, lp1, lp2, ltexte, lextra){
  return { type: ltype, p1: lp1, p2: lp2, texte : ltexte, extra : lextra};
}
function trieEtAjuste(tA, tB, tC){ // tri par taille de tA[x].area
  let lTri = [];
  for(let i = 0; i < tA.length; i++){
    lTri.push({idx:i, value:tA[i].area()});
  }
  lTri.sort(function(a, b){ return (a.value > b.value) ? -1: 1; });
  
  let tt = { a:[], b:[], c:[] };
  for(let i = 0; i < lTri.length; i++){
    let it = lTri[i].idx;
    tt.a.push(tA[it]);
    tt.b.push(tB[it]);
    tt.c.push(tC[it]);
  }
  let retour = {a:[], b:[], c:[] };
  for(let i = 0; i < tt.b.length; i++){
    let cT = new CSG.Vector2D(gTaillePage.x * (i+1), 0);
    let delta = cT.minus(utils.centre(tt.a[i].getBounds()));
    retour.a.push(tt.a[i].translate(delta));
    retour.b.push(deplaceTriangle(tt.b[i], delta));
    retour.c.push(deplacePDF(tt.c[i], delta));
  }
  return retour;
}
function deplacePDF(lPDF, delta){
  let retour = [];
  for(let i = 0; i < lPDF.length; i++){
    if(lPDF[i] !== undefined){
      switch(lPDF[i].type){
        case 'L':
        case 'D':
        case 'M':
          retour.push(pushPDF(lPDF[i].type, lPDF[i].p1.plus(delta), lPDF[i].p2.plus(delta), lPDF[i].texte));
          break;

        case 'T':
        case 'G':
        case 't':
          retour.push(pushPDF(lPDF[i].type, lPDF[i].p1.plus(delta), lPDF[i].p2, lPDF[i].texte, lPDF[i].extra));
          break;

        case 'P':
          retour.push(lPDF[i]);
          break;
      }
    }
  }
  return retour;
}
function deplaceTriangle(lTriangle, depl){
  return lTriangle.map(x => x.translate(depl));
}
function afficheTempsCalcul(msDebut){
  let msFin = (new Date()).getTime();
  let ds = Math.floor((msFin - msDebut)/1000);
  console.log('#Executé en ', (ds / 60).toFixed(0), 'min.', (ds % 60));
}
function supprimeSListe(liste, aSupprimer){
  return liste.filter((el) => ! aSupprimer.includes(el));
}

function chercheNPL(a, n1, n2){
  if(a.groups[n1] != a.groups[n2]){
    return false;
  }
  
  for(let ni = 0; ni < a.npl.length; ni++){
    if((a.npl[ni][0] == n1) && (a.npl[ni][1] == n2)){
      return false;
    }
    if((a.npl[ni][0] == n2) && (a.npl[ni][1] == n1)){
      return false;
    }
    
  }
  return true;
}

function depliePage(a, n, rot){
  let lPageTriangles = [];
  poseTriangle(a, n, rot);
  lPageTriangles.push(n);
  a.lKO = [];
  let nbT = a.csg.polygons.length;
  let nbF = 1;
  let nbOK;
  do{
    nbOK = 0;
    let tmp = gLAff.map(el => el);
    // supprime les triangles des pages déjà calculées
    for(let i = 0; i< a.lTPage.length; i++){
      tmp = supprimeSListe(tmp, a.lTPage[i]);
    }

    for(let i = 0; i < tmp.length; i++){
      let x = tmp[i];
      for(let j = 0; j < a.V[x].length; j++){
        let y = a.V[x][j].T;
        if(gLAff.indexOf(y) == -1){
          if(chercheNPL(a, x, y)){
            if(lieTriangle(a, x, y)){
              lPageTriangles.push(y);
              nbOK++;
            }
          }
        }
      }
    }
    nbF += nbOK;
  }while((nbOK > 0) && (gLAff.length < nbT));
  if (params.mode == 'dev'){ console.log('# T.',n, ':', nbF, 't.'); }

  return lPageTriangles;
}
function poseTriangle(a, n, rot = 0){
  a.cag[n] = poseAPlat(a, n)
  if(rot != 0){
    a.cag[n] = a.cag[n].rotateZ(rot);
  }
  a.cumul.push(a.cag[n].expandToCAG(gep_bord));
  gLAff.push(n);
  a.T[n] = [1, 1, 1];
}
function lieTriangle(a, n1, n2){
  let tmp;
  let chIdx = Math.max(n1, n2) + '_' + Math.min(n1, n2);
  if(a.lKO.indexOf(chIdx) > -1){ return false; }
  
  // recherche des indices concernés
  let i11 = rechIndexVoisin(a, n1, n2);
  let i12 = getpt2(i11);
  let i21 = a.V[n1][i11].n1;
  let i22 = a.V[n1][i11].n2;

  let poly1 = a.cag[n1];
  let pa1 = poly1.points[i11];
  let pa2 = poly1.points[i12];

  let poly2 = poseAPlat(a, n2);
  let pb1 = poly2.points[i21];
  let pb2 = poly2.points[i22];

  poly2 = poly2.translate(pa1.minus(pb2));// deplace poly2 de (pa1 - pb2)
  pb1 = poly2.points[i21];
  pb2 = poly2.points[i22];	

  // tourne poly2 autour de pb2 de façon à ce que pb1 = pa2
  let angle = utils.calcTriangleAngleB(pb1, pb2, pa2);
  if(angle !== null){
    tmp = poly2.rotate(pb2, [0,0,1], angle);
    if(pa2.distanceTo(tmp.points[i21]) > gPrec){
      tmp = poly2.rotate(pb2, [0,0,1], 360-angle);
    }
  }else{
    tmp = poly2.rotate(pa1, [0,0,1], 180);
  }

  poly2 = tmp;
  // vérifie que le triangle ne recouvre pas un triangle déjà placé
  let tNouv = poly2.innerToCAG().subtract(poly2.expandToCAG(gep_bord));
  let nC = a.cumul.length - 1;
  let ok = a.cumul[nC].intersect(tNouv).area() === 0;
  if(ok){
    // verifie qu'ajouter le triangle ne fasse pas déborder la page
    let tmpCumul = a.cumul[nC].union(poly2.expandToCAG(gep_bord));
    let d = utils.getTaille(tmpCumul);
    ok = (d.x <= gTaillePage.x) && (d.y <= gTaillePage.y);
    if(ok){
      a.cag[n2] = tmp;
      a.cumul[nC] = tmpCumul;
      gLAff.push(n2);
      a.T[n2]= [1, 1, 1];
      a.T[n2][i21] = vXp_LIE;
      a.T[n1][i11] = vXp_LIE;
    }
  }
  if(!ok){
    a.lKO.push(n1 + '_' + n2);
  }
  return ok;
}
function getpt2(p1){ return (p1 + 1) % 3; } // bouclage circulaire dans triplet
function afficheTriangle(a, n){
  let poly = a.cag[n];
  let lcag = [], lpdf = [];
  let p1, p2;
  /* PDF
   * 
   * line/dash  : L/D, p1, p2   Affiche Ligne/pointillés entre p1 et p2
   * text       : T/t, p, txt   Affiche Texte au point P (type T ou t)
   * page       : P             Ajoute une page
   */

  // Triangle
  for(let i = 0; i < poly.points.length; i++){
    let t = a.T[n][i];
    let estCoP = a.V[n][i].estCoP;
    let sens = a.V[n][i].sens;
    let c, cP;
    if (t < 10){
      c = "blue";
      cP = 'L';
    }else{
      if(estCoP){
        c = null;
        cP = null;
      }else{
        if(sens == 'M'){
          c = "maroon";
          cP = 'M';
        }else{
          c = "green";
          cP = 'D';
        }
      }
    }
    
    if(c !== null){
      p1 = poly.points[i];
      p2 = poly.points[getpt2(i)];
      lcag.push(color(c, cylinder({start:p1, end:p2, r:0.05})));
      n1 = n;
      n2 = a.V[n][i].T;
      if(n1> n2){
        n1 = n2;
        n2 = n;
      }
      lpdf.push(pushPDF(cP, p1, p2, n1+'_'+n2,0));
    }
  }

  // n° Triangle
  p1 = utils.centroid(poly);
  lcag.push(color('green', nombreCentre(p1, n, false)));
  lpdf.push(pushPDF('T', p1, 5, n, 0));
  
  let tmp = poly.scale(gPCNumVoisin);
  tmp = tmp.translate(p1.minus(utils.centroid(tmp)));
  // n° voisins
  let naf = 0;
  for(let i = 0; i < a.V[n].length; i++){
    if(a.T[n][i] < 10){ // Si le voisin est d'un type à afficher
      //let pt1 = tmp.points[i], pt2 = tmp.points[getpt2(i)];
      let pt1 = poly.points[i], pt2 = poly.points[getpt2(i)];
      //let c = utils.centroid({points:[pt1, pt2, p1]});
      let c = utils.centroid({points:[pt1, pt2]});
      let nV = a.V[n][i].T;
      //lcag.push(color("black", nombreCentre(c, nV, true)));
      lcag.push(color("black", nombreCentre(c, nV, false)));
      lpdf.push(pushPDF('t', c, 360-angle(pt1.x, pt1.y, pt2.x, pt2.y), nV, n));
      naf++;
    }
  } 
  return {cag: lcag, pdf: lpdf};
}
function poseAPlat(a, n){
  let p = a.faceCsg[n];
  const v1 = p.vertices[0].pos, v2 = p.vertices[1].pos, v3 = p.vertices[2].pos;
  const tC = new CSG.Connector(v1, v2.minus(v1), p.plane.normal);
  const z0xC = new CSG.Connector([0, 0, 0], [0,v2.minus(v1).length(), 0.2], [0, 0, 1]);
  const tb = tC.getTransformationTo(z0xC, false, 0);
  let pp = (CSG.fromPolygons([p]).transform(tb)).polygons[0];

  let p2 = pp.vertices.map(v => new CSG.Vector2D(v.pos._x, v.pos._y));
  let poly2D = new CSG.Path2D(p2, true);
  return poly2D;
}
function aVoisinCoPlanaire(v){
  let ok = false;
  for(let i = 0; i< v.length; i++){
    if(v[i].estCoP){ ok = true; break; }
  }
  return ok;
}
// Given two triangles p1 & p2 return "mountain" or "valley".
function classify(p1, p2) {
// Find the unshared vertex in each triangle (u1 & u2).
const s1 = new Set(p1.vertices.map(v => v.pos));
const s2 = new Set(p2.vertices.map(v => v.pos));
const u1 = [...s1].filter(v => !s2.has(v))[0];
const u2 = [...s2].filter(v => !s1.has(v))[0];
const distBetweenUnsharedVertices = u1.distanceTo(u2);
const distBetweenHeadsOfPlaneNormalsFromUnsharedVertices =
u1.plus(p1.plane.normal).distanceTo(u2.plus(p2.plane.normal));
if (distBetweenUnsharedVertices < distBetweenHeadsOfPlaneNormalsFromUnsharedVertices) {
  return "M";
}
return "V";
}
function trie(t1, t2){
  let communs = [];
  let uniques = [];
  for(let i = 0; i < t1.length; i++){
    let pt1 = t1[i].pos;
    let ok = false;
    for(let j = 0; j < t2.length; j++){
      let pt2 = t2[j].pos;
      if(pt1.distanceTo(pt2) < gPrec){
        ok = true;
        communs.push(pt1);
      }
    }
    if(!ok){
      uniques.push(pt1);
    }
  }
  return {communs, uniques};
}
function rechIndexVoisin(a, iv, i){
// retourne l'indice du voisin iv ayant pour voisin i
  let n=0, max_n = a.V[iv].length;
  while ((a.V[iv][n].T != i)&&(n <= max_n)){ n++; }

  if(n>max_n){
    throw "Les triangles " + iv +" et " + i + " ne sont pas voisins";
  }

  return (n <= max_n) ? n: -1;
}

function fait_nombres(){
var np = [
[[0,0],[0,16],[8,16],[8,0],[0,0]],
[[0,8],[8,16],[8,0]],
[[0,12],[0,16],[8,16],[8,8],[0,8],[0,0],[8,0]],
[[0,13],[0,16],[8,16],[8,11],[4,8],[8,5],[8,0],[0,0],[0,3]],
[[8,8],[0,8],[6,16],[6,0]],
[[8,16],[0,16],[0,8],[8,8],[8,0],[0,0]],
[[8,16],[0,8],[0,0],[8,0],[8,8],[0,8]],
[[0,16],[8,16],[0,0]],
[[4,9],[1,12],[1,16],[7,16],[7,12],[4,9],[8,7],[8,0],[0,0],[0,7],[4,9]],
[[8,8],[0,8],[0,16],[8,16],[8,0],[0,0]]
];
for(var i in np)
    _num[i] = new CSG.Path2D(np[i]).rectangularExtrude(1, 0.2, 2, true).scale(_gTextScale);
}
function nombreCentre(center, n, estPetit){
	var label, B, d, dx, dy;
		
	label = nombre(n);	
	if(estPetit)label = label.scale(0.75);
	B = label.getBounds();
	d = center.minus(B[1].minus(B[0]).dividedBy(2));
	
	return label.translate(d);
}
function nombre (n){
	var i, ch, r, c, t;
	
	if (_num.length === 0)fait_nombres();

	if(typeof _nb[n] === 'undefined'){
		ch = n.toString();
		r = [];
		for(i=0; i<ch.length; i++){
		    c = ch.charCodeAt(i) - 48;
	    	t = _num[c].translate([i*11*_gTextScale, 0]);
			r.push(t);
		}
		r = union(r);
		_nb[n] = r;
	}else{
		r = _nb[n];
	}
	return r;
}

utils = function () {
utils.lit_off = function (off){ // chargement du modele au format .OFF
  let fl = off.split('\n');
  if(fl[0].startsWith("OFF")){
    fl.shift(); // supprime 1e ligne si [OFF]
  }
  let nbs = fl.shift().split(' '); // Lit 2e ligne [#points #polys 0]
  let nbPts  = Number(nbs[0]);
  let nbPolys = Number(nbs[1]);
  let points = [];
  for(let i = 0; i < nbPts; i++){ // lecture des points
    nbs = fl[i].split(' ').map(Number);
    points.push(new CSG.Vertex(new CSG.Vector3D(nbs[0], nbs[1], nbs[2])));
  }

  let polys = [];
  let f = [];
  let lPts = [];
  for(let i = 0; i < nbPolys; i++){ // lecture des polygones
    nbs = fl[nbPts + i].split(' ').map(Number);

    let pts = [];
    for(let j = 1; j <= nbs[0]; j++){ // preparation des pts du poly
      pts.push(points[nbs[j]].pos);
    }
    f.push(CSG.Polygon.createFromPoints(pts));//.flipped()); // flipped() pour bonne normale
    nbs.shift();
    lPts.push(nbs);
  }
  return {csg:CSG.fromPolygons(f), lPts:lPts, V:[], T:[], lKO:[], cumul:[]};
}
utils.poseAuSol = function (csg){ // pose le solide sur l'axe Z
    var b, d;
    
    b = csg.getBounds();
    d = b[1].minus(b[0]).dividedBy(2);
    return csg.translate([0, 0,-b[1].z+2*d.z]);
}
utils.csgFromSegments = function (segments) {
  let output = [];
  segments.forEach(segment => output.push(
    rectangular_extrude(segment, { w:2, h:1 })
  ));
  return union(output);
}
utils.getTaille = function (g){
  let b = g.getBounds();
  return b[1].minus(b[0]);
}
utils.centroid = function (p){ // retourne le centroid du polygone p
  var c = new CSG.Vector2D(0,0),
    v = p.points;
    vl = v.length;
	
	for(var i = 0; i < vl; i++){
		c = c.plus(v[i]);
	}
	
	return c.dividedBy(vl);
}
utils.centre = function (p){
  return p[0].plus(p[1].minus(p[0]).dividedBy(2));
}
utils.flatNonRec = function (input) {
  const stack = [...input];
  const res = [];
  while (stack.length) {
    // On sort une valeur de la pile
    const next = stack.pop();
    if (Array.isArray(next)) {
      // On place les éléments qui sont des tableaux dans
      // la pile sans modifier l'entrée
      stack.push(...next);
    } else {
      res.push(next);
    }
  }
  // On inverse le résultat pour revenir 
  // à l 'ordre de l'entrée
  return res.reverse();
}
utils.calcTriangleAngleA = function (a, b, c){
  let Ab = Math.abs(b.x - c.x);
  let Ac = Math.abs(b.y - c.y);  
  let A = Math.sqrt((Ab * Ab) + (Ac * Ac));

  let Bb = Math.abs(a.x - c.x);
  let Bc = Math.abs(a.y - c.y);
  let B = Math.sqrt((Bb * Bb) + (Bc * Bc));

  let Cb = Math.abs(a.x - b.x);
  let Cc = Math.abs(a.y - b.y);
  let C = Math.sqrt((Cb * Cb) + (Cc * Cc));

  let x = (A * A + C * C - B * B) / (2*A * C);
  return (Math.abs(x) <= 1) ? utils.radians(Math.acos(x)) : null;
}
utils.calcTriangleAngleB = function (a, b, c){
  let Ab = Math.abs(b.x - c.x);
  let Ac = Math.abs(b.y - c.y);
  let A = Math.sqrt((Ab * Ab) + (Ac * Ac));

  let Bb = Math.abs(a.x - c.x);
  let Bc = Math.abs(a.y - c.y);
  let B = Math.sqrt((Bb * Bb) + (Bc * Bc));

  let Cb = Math.abs(a.x - b.x);
  let Cc = Math.abs(a.y - b.y);
  let C = Math.sqrt((Cb * Cb) + (Cc * Cc));
  
  let x = (A * A + C * C - B * B) / (2 * A * C);
  return (Math.abs(x) <= 1) ? utils.radians(Math.acos(x)) : null;
}
utils.calcTriangleAngleC = function (a, b, c){
  let Ab = Math.abs(b.x - c.x);
  let Ac = Math.abs(b.y - c.y);
  let A = Math.sqrt((Ab*Ab) + (Ac*Ac));

  let Bb = Math.abs(a.x - c.x);
  let Bc = Math.abs(a.y - c.y);
  let B = Math.sqrt((Bb*Bb) + (Bc*Bc));

  let Cb = Math.abs(a.x - b.x);
  let Cc = Math.abs(a.y - b.y);
  let C = Math.sqrt((Cb*Cb) + (Cc*Cc));

  let x = (A*A + B*B - C*C) / (2*A*B);    
  return (Math.abs(x)<=1) ? utils.radians(Math.acos(x)) : null;
}
utils.radians = function (d){ return d * 180 / Math.PI; }

}

!-->
	</textarea>

  <textarea id="zc_tranches01" style="display:none;">
<!--
// Affiche un volume en tranches selon les parametres choisis

function getParameterDefinitions() { // parametres
  return [
    { name: 'g1', type: 'group', caption: 'Modele'},
    { name: 'echelle', type: 'float', initial: 1, caption: 'Echelle?' },
    { name: 'rX',      type: 'int',   initial: 0, caption: 'Rotation X:' },
    { name: 'rY',      type: 'int',   initial: 0, caption: 'Rotation Y:' },
    { name: 'rZ',      type: 'int',   initial: 0, caption: 'Rotation Z:' },

    { name: 'g2', 		 type: 'group', caption: 'Tranches'},
    { name: 'ec',      type: 'int',   initial: 3, caption: 'Ep. carton (mm)?' },
    { name: 'dk',      type: 'float', initial: 1.5, caption: 'Decalage  (mm)?' },

    { name: 'lpage',   type: 'float', initial: 210, caption: 'Larg. page (mm)?' },
    { name: 'hpage',   type: 'float', initial: 297, caption: 'Haut. page (mm)?' },

    { name: 'mode',    type: 'choice',initial: 3, caption: 'Mode:', values:[3,2], captions:['Tranches 3d','Tranches 2d']}
  ];
}

function main(params) {
const cols = ["orange", "tan"];// couleurs des tranches
var V, r, b, d, de, b1, z, cn, nbT, t2d, t2dd, b2;


// Recupere le volume
V = scale(params.echelle, rotate([params.rX, params.rY, params.rZ], volume()));
r = []; // pour stocker le rendu voulu

// Calcule ses dimensions :
b = V.getBounds(); // pts extremes du volume (plus petit et plus grand)
V = translate([0, 0, -b[0].z], V); // realigne au dessus de Z=0
b = V.getBounds();

d = b[1].minus(b[0]); // dimensions = difference entre ces deux points
de = [d.x, d.y, d.z].map(Math.round); // arrondi pour l'affichage

if(params.mode == 1){ // affiche le volume (avec echelle et rotations choisies)
  r.push(color("crimson", V));

}else if (params.mode == 3){ // Affiche les tranches en 3d
  b1 = translate(b[0], cube({size:[d.x, d.y, params.ec], center:false}));
  z = b[0].z + params.ec / 2;
  cn =0;
  nbT = 0;
  do{
    t2d = union(faitTranche(V, b1, z));
    t3dd = t2d.extrude({offset:[0, 0,params.ec]});
    r.push(color(cols[cn], translate([0, 0, z], t3dd)));
    z += params.ec;
    cn = 1 - cn;
    nbT++;
  }while(z < d.z);
  r.push(texte("nb tranches:"+ nbT, 0.5).translate([b[1].x,-40,0]));
} else if (params.mode == 2){ // affiche les tranches en 2d
    // affichage cadre page
    cadre = difference(
      square({size:[params.lpage + 8, params.hpage + 8], center:false}),
      translate([1,1], square({size:[params.lpage + 6, params.hpage + 6], center:false}))
    );
    bCadre = cadre.getBounds();

		cadreT = difference(square({size:[d.x+8, d.y+8], center:false}),
			translate([1,1], square({size:[d.x+6, d.y+6], center:false})));
		//r.push(cadre);

    b1 = translate(b[0], cube({size:[d.x, d.y, params.ec], center:false}));
    z = b[0].z + params.dk;
    co = {x:1.5, y:1.5};

    nbT = Math.ceil(d.z / params.ec);

	  var data = [], tp;

	  maxTL = Math.floor(params.lpage / (d.x+5));
	  console.log("max tranches/ligne : ", maxTL);
    maxLP = Math.floor(params.hpage / (d.y+5));
    console.log("max lignes/page : ", maxLP);
		console.log("Nb Pages : ", Math.ceil(nbT/ (maxTL * maxLP)));
    n =1 ;

    // data : .t = cadre:1 | ligne:2 | texte:3 | page:4

    nPage = 0;
    nLigneDsPage = 0;
    nTrancheDsLigne = 0;
    nTranche = 0;
		afficherPage = true;
		dkPage = 0;
		while (nTranche < nbT){
				if (afficherPage){
					r.push(translate([dkPage, 0], cadre));
					afficherPage = false;
					dx = dkPage + 8;
					dy = 4;
					if (nPage > 0){
						data.push({t:4});
					}
				}

        tmp = faitTranche(V, b1, z);
        if (tmp.length >0){
          t2d = union(tmp);
          b2 = t2d.getBounds();
          t2d = translate(b2[0].times(-1), t2d);
        }

        r.push(translate([dx, dy], t2d));
        r.push(translate([dx-2, dy-2], cadreT));

				x1 = 6 + (d.x + 8) * nTrancheDsLigne;
				y1 = 6 + (d.y + 8) * nLigneDsPage;
				var typeT;
				if(nLigneDsPage ==0){
					if(nTrancheDsLigne == 0){
					  typeT = 10;
					} else {
					  typeT = 11;
					}
				}else{
					if(nTrancheDsLigne == 0){
					  typeT = 12;
					} else {
					  typeT = 13;
					}
				}
        data.push({t:typeT,
					x1:x1, y1:y1,
					x2:x1 + d.x + 8, y2:y1 + d.y + 8
				});

 				for (var np in t2d.sides){
					sp = t2d.sides[np];
					data.push({t:2,
						x1:x1 +4 + sp.vertex0.pos.x, y1:y1 +4 + sp.vertex0.pos.y,
						x2:x1 +4 + sp.vertex1.pos.x, y2:y1 +4 + sp.vertex1.pos.y
					});
				}

        z += params.ec;
        nTranche++;

        if (nTrancheDsLigne < maxTL-1){
					nTrancheDsLigne++;
					dx += d.x + 8;
				}else{
					nTrancheDsLigne = 0;
					if (nLigneDsPage < maxLP-1){
					  nLigneDsPage++;
					  dy += d.y + 8;
					  dx = dkPage + 8;
					 }else{
						 nLigneDsPage = 0;
						 nTrancheDsLigne = 0;
						 nPage++;
						 dkPage += params.lpage + 18;
						 afficherPage = true;
					 }
				}


		}

		dexport=JSON.stringify(data);
//		try{
		  localStorage.setItem("tr1_data", dexport);
		  localStorage.setItem("tr1_dx", params.lpage);
		  localStorage.setItem("tr1_dy", params.hpage);
//		}catch(err){};
    //console.log(dexport);
}

if(params.mode == 3){ // affiche les dimensions (mode "tranches 3d")
  r.push(translate([b[1].x,20,0], texte("larg.:"+ de[0].toString()+" mm", 0.5)));
  r.push(translate([b[1].x,0,0], texte("long.:"+ de[1].toString()+" mm", 0.5)));
  r.push(translate([b[1].x,-20,0], texte("haut.:"+ de[2].toString()+" mm", 0.5)));
}

return r;
}

function faitTranche(volume, tranche, h){
  return vol2surf(translate([0, 0, -h],
    volume.intersect(tranche.translate([0, 0, h]))));
}

// retourne la surface formee par le volume avec l'axe z (à 0)
function vol2surf(vol, orig = 0){
var n, pts, ok, P, i, pt;
let S = [];

for(n = 0; n < vol.polygons.length; n++){
  pts = [];
  P = vol.polygons[n];
  ok = true;
  for(i=0; (i < P.vertices.length) && ok; i++){
    pt = P.vertices[i].pos;
    if(Math.abs(pt.z - orig)< 0.05){
      pts.push([pt.x, pt.y]);
    } else {
      ok = false;
    }
  }
  if (ok){
    S.push(polygon(pts));
  }
}

return S;
}

// Affiche une chaine de caracteres
function texte(ch, echelle=1){
  let text = vectorText(ch);
  var r = csgFromSegments(text);
  if (echelle != 1){
    r = scale(echelle, r);
  }

  return r;
}

// transforme des segments en volume
function csgFromSegments (segments) {
  let output = [];
  segments.forEach(segment => output.push(
    rectangular_extrude(segment, { w:2, h:1 })
  ));
  return union(output);
}
!-->
  </textarea>

  <textarea id="zc_tranches02" style="display:none;">
<!--
function getParameterDefinitions() {
  return [
    { name: 't0', type:'group', caption:'TRANCHAGE 2 AXES'},
    { name: 'ech',type: 'number', initial: 1, caption: 'Echelle' }, 
    { name: 'rX', type: 'int',   initial: 0, caption: 'Rotation X:' },
    { name: 'rY', type: 'int',   initial: 0, caption: 'Rotation Y:' },
    { name: 'rZ', type: 'int',   initial: 0, caption: 'Rotation Z:' },
    { name: 'nbC',type: 'int', initial: 3, caption: 'Nb Colonnes (beige)' }, 
    { name: 'nbL',type: 'int', initial: 3, caption: 'Nb Lignes (orange)' },
    { name: 'eC', type: 'int', initial: 3, caption: 'Ep. Carton (mm)' },
    { name: 'mode',type: 'choice', initial: 1, caption:'Mode', captions:['Vue 3d','Vue 3d eclatee V', 'Vue 3d eclatee H', 'Vue 2d'], values:[30,31,32,2]},
    { name: 't1',  type: 'group', caption:'Gabarit'},
    { name: 'larg', type: 'number', initial: 210, caption: 'Largeur (mm)' }, 
    { name: 'haut', type: 'number', initial: 297, caption: 'Hauteur (mm)' }
  ];
}

function ajoutePtsDePoly(poly){
	var ret = [];
	for (var np = 0; np < poly.sides.length; np++){
		var sp = poly.sides[np];
		ret.push({t:2,
  		x1: 4 + sp.vertex0.pos.x, y1: 4 + sp.vertex0.pos.y,
			x2: 4 + sp.vertex1.pos.x, y2: 4 + sp.vertex1.pos.y
		});
	}
	return ret;
}

function main(){

var r2d = [], v, tmp, i, b, tr, d, bz, t2, t3, t4;
var nLignes = [], nColonnes = [], rL = [], rC = [], urL, urC;

// volume
v = center(true, scale(params.ech, rotate([params.rX, params.rY, params.rZ], volume())));
b = v.getBounds();
d = b[1].minus(b[0]);

for(i = 0.5; i< params.nbL; i++){ // lignes
  tr =rotate([90,0,0], faitLigne(i, v, params.nbL, params.eC));
  bz = tr.getBounds()[0].z;
  tr = union(vol2surf(tr, bz));
  tr = translate([0,bz +3, 0], rotate([-90,0,0], tr.extrude({offset:[0,0,params.eC]})));
  rL = rL.concat(tr);
}
urL = union(rL);

for(i = 0.5; i < params.nbC; i++){ // colonnes
  tr =rotate([0,90,0], faitColonne(i, v, params.nbC, params.eC));
  bz = tr.getBounds()[0].z;
  tmp = union(vol2surf(tr, bz));
  tr = translate([-bz, 0, 0], rotate([0,-90,0], tmp.extrude({offset:[0,0,params.eC]})));
  rC = rC.concat(tr);
}
urC = union(rC);

tmp = scission3d(urC.intersect(urL)); // encoches
var miH = [], miB = [], miT = [];
for(i = 0; i < tmp.length; i++){
  var tt = diviseVolume(tmp[i], d);
  miH.push(tt[1]);
  miB.push(tt[2]);
  miT.push(tt[0]);
}
var umiH = union(miH), umiB = union(miB);
var data = [];

if (params.mode == 2){ // rendu 2d
  var r = [], n, t2, t3, h;

  for(n = 0; n < rL.length; n++){
      t2 = rL[n].subtract(miT);
      t3 = t2.union(rL[n].intersect(umiH));
    r.push(translate([-params.larg * n, 0],
      square({size:[params.larg+4, params.haut+4], center:true})
      .subtract(square({size:[params.larg, params.haut], center:true}))));
		t4 = tourneEt2d(t3, [90, 0, 0]);
    r.push(translate([-params.larg * n, 2], t4));

		t4 = translate(t4.getBounds()[0].times(-1), t4);
		if(n > 0){ data.push({t:4}); }
		data.push(...ajoutePtsDePoly(t4));
  }

  h = params.haut;
  for(n = 0; n < rC.length; n++){
    t2 = rC[n].subtract(miT);
    t3 = t2.union(rC[n].intersect(umiB));
    r.push(translate([-params.larg*n, h],
      square({size:[params.larg+4, params.haut+4], center:true})
      .subtract(square({size:[params.larg, params.haut], center:true}))));
		t4 = tourneEt2d(t3, [0, -90, 0]);
    r.push(translate([-params.larg*n, h+2], t4));

		t4 = translate(t4.getBounds()[0].times(-1), t4);
		data.push({t:4});
		data.push(...ajoutePtsDePoly(t4));
  } 
 
	var dexport = JSON.stringify(data);
//	try{
	localStorage.setItem("tr1_data", dexport);
	localStorage.setItem("tr1_dx", params.larg);
	localStorage.setItem("tr1_dy", params.haut);
//	}catch(err){};
//  console.log(dexport);

  return r;
    
} else { // rendu 3d
  var ee, cv;
  if (params.mode == 30){
    ee = 0;
    cv = [1,0,0,0.2];
  } else {
    ee = 1.2;
    cv = "crimson";
  }

	if(params.mode == 31){
	  return [color("tan", translate([0, d.y * ee, d.z / 2], urC.subtract(miT).union(miB)))
		       ,color("orange", translate([0, -d.y * ee, d.z / 2], urL.subtract(miT).union(miH)))
		         ,color(cv, translate([0, 0, d.z / 2], v))
		  ];
	} else {
    return [color("tan", translate([d.x * ee, 0, d.z / 2], urC.subtract(miT).union(miB)))
           ,color("orange", translate([-d.x * ee, 0, d.z / 2], urL.subtract(miT).union(miH)))
           ,color(cv, translate([0, 0, d.z / 2], v))
      ];
  }
}
}

function tourneEt2d(vol, angle){
  var t = rotate(angle, vol);
  return union(vol2surf(t, t.getBounds()[1].z));
}

function faitColonne(i, V, nbC, ec){
	var vb = V.getBounds();
	var vd = vb[1].minus(vb[0]);
  var tNc1 = [[0, vb[0].x],[nbC, vb[1].x]];
  var b2 = lookup(i, tNc1);
  //var tmp = translate([b2 -ec, vb[0].y, -vd.z/2], cube({size:[ec, vd.y*3, vd.z*3], center:false}));
  var tmp = translate([b2 -ec, -500, -500], cube({size:[ec, 1000, 1000], center:false}));
  return V.intersect(tmp);
}

function faitLigne(i, V, nbL, ec){
	var vb = V.getBounds();
	var vd = vb[1].minus(vb[0]);
  var tNl1 = [[0, vb[0].y],[nbL, vb[1].y]];
  var b2 = lookup(i, tNl1);
  //var tmp = translate([vb[0].x, b2 -ec, -vd.z/2], cube({size:[vd.x*3, ec, vd.z*3], center:false}));
  var tmp = translate([-500, b2 -ec, -500], cube({size:[1000, ec, 1000], center:false}));
  return V.intersect(tmp);
}

function diviseVolume(vol, volD){
  var b = vol.getBounds();
  var d = b[1].minus(b[0]);
  var cDemi = cube({size:[d.x, d.y, d.z/2], center:false});
  var cTout = translate([b[0].x, b[0].y,-500], cube({size:[d.x, d.y, 1000], center:false}));    
  return [cTout,
          vol.intersect(translate(b[0], cDemi)),
          vol.intersect(translate([b[0].x, b[0].y, b[0].z + d.z/2], cDemi))
  	];
}

function sortNb		(E){ // returns E numerically sorted and deduplicated
	return E.sort(function(a, b) {return a-b}).filter(
	    function(item, pos, ary) {return !pos || item != ary[pos - 1]});
}

function compare3d	(v1, v2){ // returns true if V1 and V2 are at the same position
	return (v1.pos.x == v2.pos.x) && (v1.pos.y == v2.pos.y) && (v1.pos.z == v2.pos.z);
}

function compare2d			(v1, v2){ // returns true if V1 and V2 are at the same position
	return (v1.pos.x == v2.pos.x) && (v1.pos.y == v2.pos.y);
}

function scission2d			(geom){
	var i,j,i1,j1,ok,ti,tj,z,zz = [], P = geom.sides, RScission = [];

// construit table de correspondance entre Polygones (P)
// build polygons lookup table
	for (i = 0; i < P.length; i++) {
		ti = [P[i].vertex0, P[i].vertex1];
		z = [];
		for (j = 0; j < P.length; j++) {
			tj = [P[j].vertex0, P[j].vertex1];
			ok = false;
			for (i1 = 0; i1 < ti.length; i1++)
				for(j1 = 0; j1 < tj.length; j1++)
					{if (!ok)ok = compare2d(ti[i1], tj[j1]);}
			if (ok){z.push(parseInt(j));}
		}
		z = sortNb(z);
		zz.push({e:0, d:z});
		// console.log(i, z.toString());
	}

// regroupe les correspondances des polygones se touchant
// boucle ne s'arrêtant que quand deux passages retournent le même nb de polygones
// merge lookup data from linked polygons as long as possible
	ok = false;
	nElOk = 0;
	do {
		lnElOk = nElOk;
		nElOk = 0;
		for (i = 0; i < zz.length; i++) {
			if (zz[i].e >= 0) {
				nElOk++;
				for (j = 0; j < zz[i].d.length; j++) {
					a = zz[i].d[j];
					if (zz[a].e >= 0)
						if (i != a) {
							zz[i].d = sortNb(zz[i].d.concat(zz[a].d));
							zz[a].e = -1;
						}
				}
			}
		}
		ok = lnElOk == nElOk;
	}while (!ok);

// construit le tableau des CAG à retourner
// build array of CAG to return
	for (i = 0; i < zz.length; i++) {
		if (zz[i].e >= 0) {
			z = [];
			for (j = 0; j < zz[i].d.length; j++)
				z.push(P[zz[i].d[j]]);
			RScission.push(CAG.fromSides(z));
		}
	}

	return RScission;
}

function scission3d	(geom){
  var i,Pl, j,i1,j1,ok,ti,tj,z,zz = [], P, RScission, til, tjl, tii1, zzl, zzdl;
// construit table de correspondance entre Polygones (P)
// build polygons lookup table
  P = geom.toPolygons();
  RScission = [];
  Pl = P.length;
  for (i = 0; i < Pl; i++){
	ti = P[i].vertices;
	z = [];
	for (j = 0; j < Pl; j++){
      tj = P[j].vertices;
	  ok = false;
	  for (i1 = 0; i1 < ti.length; i1++){
	    tii1 = ti[i1];
		for(j1 = 0; j1 < tj.length; j1++)
		  if (!ok)ok = compare3d(tii1, tj[j1]);
	  }
	  if (ok)z.push(parseInt(j));
	}
	z = sortNb(z);
	zz.push({e:0, d:z});
  }

// regroupe les correspondances des polygones se touchant
// boucle ne s'arrêtant que quand deux passages retournent le même nb de polygones
// merge lookup data from linked polygons as long as possible
  ok = false;
  nElOk = 0;
  do {
    lnElOk = nElOk;
	nElOk = 0;
	for (i = 0; i < zz.length; i++){
	  if (zz[i].e >= 0) {
	    nElOk++;
		for (j = 0; j < zz[i].d.length; j++){
		  a = zz[i].d[j];
		  if (zz[a].e >= 0)
		    if (i != a) {
			  zz[i].d = sortNb(zz[i].d.concat(zz[a].d));
			  zz[a].e = -1;
			}
		}
	  }
	}
	ok = lnElOk == nElOk;
  }while (!ok);

// construit le tableau des CSG à retourner
// build array of CSG to return
  for (i = 0, zzl = zz.length; i < zzl; i++) {
    if (zz[i].e >= 0) {
	  z = [];
	  for (j = 0, zzdl = zz[i].d.length; j < zzdl; j++)
	    z.push(P[zz[i].d[j]]);
	  RScission.push(CSG.fromPolygons(z));
	}
  }

  return RScission;
}
// retourne la surface formee par le volume avec l'axe z (à 0)
function vol2surf(vol, orig = 0){
var n, pts, ok, P, i, pt;
let S = [];

for(n = 0; n < vol.polygons.length; n++){
  pts = [];
  P = vol.polygons[n];
  ok = true;
  for(i=0; (i < P.vertices.length) && ok; i++){
    pt = P.vertices[i].pos;
    if(Math.abs(pt.z - orig)< 0.05){
      pts.push([pt.x, pt.y]);
    } else {
      ok = false;
    }
  }
  if (ok){
    S.push(polygon(pts));
  }
}

return S;
}
/*
function poseAPlat(p){
  const v1 = p.vertices[0].pos, v2 = p.vertices[1].pos, v3 = p.vertices[2].pos;
  const tC = new CSG.Connector(v1, v2.minus(v1), p.plane.normal);
  const z0xC = new CSG.Connector([0, 0, 0], [0,v2.minus(v1).length(), 0.2], [0, 0, 1]);
  const tb = tC.getTransformationTo(z0xC, false, 0);
  let pp = (CSG.fromPolygons([p]).transform(tb)).polygons[0];

  let p2 = pp.vertices.map(v => new CSG.Vector2D(v.pos._x, v.pos._y));
  let poly2D = new CSG.Path2D(p2, true);
  return poly2D;
}*/

!-->
  </textarea>

  <textarea id="zc_dimensions" style="display:none;">
<!--
// Affiche un volume et ses dimensions (avec parametre echelle)

// parametres
function getParameterDefinitions() {
    return [
        { name: 'echelle', type: 'float', initial: 1, caption: 'Echelle?' }
    ];
}

function main(params) {
// Récupère le volume
var V = volume().scale(params.echelle);

// Calcule ses dimensions :
var b = V.getBounds(); // pts extrêmes du volume (plus petit et plus grand)
var d = b[1].minus(b[0]); // dimensions = différence entre ces deux points
var de = [d.x, d.y, d.z].map(Math.round);

// Affiche les dimensions
var r = [];

r.push(color("red", V)); // volume en rouge

// boite inscrite en cyan transparent (r:0, v:1, b:1, t:0.2)
r.push(color([0,1,1,0.2], cube([d.x, d.y, d.z]).translate(b[0])));

// dimensions
r.push(texte("larg. :"+ de[0].toString()+" mm").scale(0.5).translate([b[1].x,20,0]));
r.push(texte("long. :"+ de[1].toString()+" mm").scale(0.5).translate([b[1].x,0,0]));
r.push(texte("haut. :"+ de[2].toString()+" mm").scale(0.5).translate([b[1].x,-20,0]));

return r;
}

// Affiche une chaine de caractères
function texte(ch){
  let text = vectorText(ch);
  return csgFromSegments(text);
}

// transforme des segments en volume
function csgFromSegments (segments) {
  let output = [];
  segments.forEach(segment => output.push(
    rectangular_extrude(segment, { w:2, h:1 })
  ));
  return union(output);
}
!-->
  </textarea>
</body>

</html>
