<!DOCTYPE html>
<html>
<!--

== OpenJSCAD.org, Copyright (c) 2016-2017, Licensed under MIT License ==
   in conjunction with other libraries by various authors (see the individual files)

Purpose:
Choose a .jscad then uses as volume() into another .jscad
-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
  <title>gilboo.net charge volume et script jscad</title>
  <link rel="stylesheet" href="min_scripts.css" type="text/css">
  <script src="dist/min_scripts.js"></script>
	<script src="pdfkit.standalone.js"></script>
	<script src="blob-stream.js"></script>
<style>
</style>
</head>

<body>

<!-- setup display of the errors as required by OpenJSCAD.js -->
  <div class="jscad-container">
    <div id="header">
      <div id="errordiv"></div>
    </div>

<!-- setup display of the viewer, i.e. canvas -->
    <!--div oncontextmenu="return false;" id="viewerContext" design-url="carton.num/tranches01.jscad"></div-->
    <div oncontextmenu="return false;" id="viewerContext" ></div>

<!-- setup display of the status, as required by OpenJSCAD.js -->
<!-- set display: block to display this -->
    <div id="tail" style="display: block;">
      <div id="statusdiv"></div>
    </div>
  </div>

  <div id="gdscripts"><!-- GD: interface pour scripts.html -->
    <span id="titreVolume">Volume:</span>
	  <input id="fichier" type="file" accept=".jscad, .stl, .obj" />
	  <select id="selectVolume">
  		<option selected disabled>(choisir volume)</option>
  	</select>
  	<select id="selectScript">
		  <option selected disabled>(choisir script)</option>
		  <option id="calc_dimensions">Dimensions</option>
		  <option id="calc_tranches01">Tranchage / 1 axe</option>
		  <option id="calc_tranches02">Tranchage / 2 axes</option>
	  </select>
	  <button id="calc_pdf">Cr&eacute;er PDF</button>
  </div>

  <textarea id="zc_tranches01" style="display:none;">
<!--
// Affiche un volume en tranches selon les parametres choisis

function getParameterDefinitions() { // parametres
  return [
    { name: 'g1', type: 'group', caption: 'Modele'},
    { name: 'echelle', type: 'float', initial: 1, caption: 'Echelle?' },
    { name: 'rX',      type: 'int',   initial: 0, caption: 'Rotation X:' },
    { name: 'rY',      type: 'int',   initial: 0, caption: 'Rotation Y:' },
    { name: 'rZ',      type: 'int',   initial: 0, caption: 'Rotation Z:' },

    { name: 'g2', 		 type: 'group', caption: 'Tranches'},
    { name: 'ec',      type: 'int',   initial: 3, caption: 'Ep. carton (mm)?' },
    { name: 'dk',      type: 'float', initial: 1.5, caption: 'Decalage  (mm)?' },

    { name: 'lpage',   type: 'float', initial: 210, caption: 'Larg. page (mm)?' },
    { name: 'hpage',   type: 'float', initial: 297, caption: 'Haut. page (mm)?' },

    { name: 'mode',    type: 'choice',initial: 3, caption: 'Mode:', values:[3,2], captions:['Tranches 3d','Tranches 2d']}
  ];
}

function main(params) {
const cols = ["orange", "tan"];// couleurs des tranches
var V, r, b, d, de, b1, z, cn, nbT, t2d, t2dd, b2;


// Recupere le volume
V = scale(params.echelle, rotate([params.rX, params.rY, params.rZ], volume()));
r = []; // pour stocker le rendu voulu

// Calcule ses dimensions :
b = V.getBounds(); // pts extremes du volume (plus petit et plus grand)
V = translate([0, 0, -b[0].z], V); // realigne au dessus de Z=0
b = V.getBounds();

d = b[1].minus(b[0]); // dimensions = difference entre ces deux points
de = [d.x, d.y, d.z].map(Math.round); // arrondi pour l'affichage

if(params.mode == 1){ // affiche le volume (avec echelle et rotations choisies)
  r.push(color("crimson", V));

}else if (params.mode == 3){ // Affiche les tranches en 3d
  b1 = translate(b[0], cube({size:[d.x, d.y, params.ec], center:false}));
  z = b[0].z + params.ec / 2;
  cn =0;
  nbT = 0;
  do{
    t2d = union(faitTranche(V, b1, z));
    t3dd = t2d.extrude({offset:[0, 0,params.ec]});
    r.push(color(cols[cn], translate([0, 0, z], t3dd)));
    z += params.ec;
    cn = 1 - cn;
    nbT++;
  }while(z < d.z);
  r.push(texte("nb tranches:"+ nbT, 0.5).translate([b[1].x,-40,0]));
} else if (params.mode == 2){ // affiche les tranches en 2d
    // affichage cadre page
    cadre = difference(
      square({size:[params.lpage + 8, params.hpage + 8], center:false}),
      translate([1,1], square({size:[params.lpage + 6, params.hpage + 6], center:false}))
    );
    bCadre = cadre.getBounds();

		cadreT = difference(square({size:[d.x+8, d.y+8], center:false}),
			translate([1,1], square({size:[d.x+6, d.y+6], center:false})));
		//r.push(cadre);

    b1 = translate(b[0], cube({size:[d.x, d.y, params.ec], center:false}));
    z = b[0].z + params.dk;
    co = {x:1.5, y:1.5};

    nbT = Math.ceil(d.z / params.ec);

	  var data = [], tp;

	  maxTL = Math.floor(params.lpage / (d.x+5));
	  console.log("max tranches/ligne : ", maxTL);
    maxLP = Math.floor(params.hpage / (d.y+5));
    console.log("max lignes/page : ", maxLP);
		console.log("Nb Pages : ", Math.ceil(nbT/ (maxTL * maxLP)));
    n =1 ;

    // data : .t = cadre:1 | ligne:2 | texte:3 | page:4

    nPage = 0;
    nLigneDsPage = 0;
    nTrancheDsLigne = 0;
    nTranche = 0;
		afficherPage = true;
		dkPage = 0;
		while (nTranche < nbT){
				if (afficherPage){
					r.push(translate([dkPage, 0], cadre));
					afficherPage = false;
					dx = dkPage + 8;
					dy = 4;
					if (nPage > 0){
						data.push({t:4});
					}
				}

        tmp = faitTranche(V, b1, z);
        if (tmp.length >0){
          t2d = union(tmp);
          b2 = t2d.getBounds();
          t2d = translate(b2[0].times(-1), t2d);
        }

        r.push(translate([dx, dy], t2d));
        r.push(translate([dx-2, dy-2], cadreT));

				x1 = 6 + (d.x + 8) * nTrancheDsLigne;
				y1 = 6 + (d.y + 8) * nLigneDsPage;
				var typeT;
				if(nLigneDsPage ==0){
					if(nTrancheDsLigne == 0){
					  typeT = 10;
					} else {
					  typeT = 11;
					}
				}else{
					if(nTrancheDsLigne == 0){
					  typeT = 12;
					} else {
					  typeT = 13;
					}
				}
        data.push({t:typeT,
					x1:x1, y1:y1,
					x2:x1 + d.x + 8, y2:y1 + d.y + 8
				});

 				for (var np in t2d.sides){
					sp = t2d.sides[np];
					data.push({t:2,
						x1:x1 +4 + sp.vertex0.pos.x, y1:y1 +4 + sp.vertex0.pos.y,
						x2:x1 +4 + sp.vertex1.pos.x, y2:y1 +4 + sp.vertex1.pos.y
					});
				}

        z += params.ec;
        nTranche++;

        if (nTrancheDsLigne < maxTL-1){
					nTrancheDsLigne++;
					dx += d.x + 8;
				}else{
					nTrancheDsLigne = 0;
					if (nLigneDsPage < maxLP-1){
					  nLigneDsPage++;
					  dy += d.y + 8;
					  dx = dkPage + 8;
					 }else{
						 nLigneDsPage = 0;
						 nTrancheDsLigne = 0;
						 nPage++;
						 dkPage += params.lpage + 18;
						 afficherPage = true;
					 }
				}


		}

		dexport=JSON.stringify(data);
//		try{
		  localStorage.setItem("tr1_data", dexport);
		  localStorage.setItem("tr1_dx", params.lpage);
		  localStorage.setItem("tr1_dy", params.hpage);
//		}catch(err){};
    //console.log(dexport);
}

if(params.mode == 3){ // affiche les dimensions (mode "tranches 3d")
  r.push(translate([b[1].x,20,0], texte("larg.:"+ de[0].toString()+" mm", 0.5)));
  r.push(translate([b[1].x,0,0], texte("long.:"+ de[1].toString()+" mm", 0.5)));
  r.push(translate([b[1].x,-20,0], texte("haut.:"+ de[2].toString()+" mm", 0.5)));
}

return r;
}

function faitTranche(volume, tranche, h){
  return vol2surf(translate([0, 0, -h],
    volume.intersect(tranche.translate([0, 0, h]))));
}

// retourne la surface formee par le volume avec l'axe z (à 0)
function vol2surf(vol, orig = 0){
var n, pts, ok, P, i, pt;
let S = [];

for(n = 0; n < vol.polygons.length; n++){
  pts = [];
  P = vol.polygons[n];
  ok = true;
  for(i=0; (i < P.vertices.length) && ok; i++){
    pt = P.vertices[i].pos;
    if(Math.abs(pt.z - orig)< 0.05){
      pts.push([pt.x, pt.y]);
    } else {
      ok = false;
    }
  }
  if (ok){
    S.push(polygon(pts));
  }
}

return S;
}

// Affiche une chaine de caracteres
function texte(ch, echelle=1){
  let text = vectorText(ch);
  var r = csgFromSegments(text);
  if (echelle != 1){
    r = scale(echelle, r);
  }

  return r;
}

// transforme des segments en volume
function csgFromSegments (segments) {
  let output = [];
  segments.forEach(segment => output.push(
    rectangular_extrude(segment, { w:2, h:1 })
  ));
  return union(output);
}
!-->
  </textarea>

  <textarea id="zc_tranches02" style="display:none;">
<!--
function getParameterDefinitions() {
  return [
    { name: 't0', type:'group', caption:'TRANCHAGE 2 AXES'},
    { name: 'ech',type: 'number', initial: 1, caption: 'Echelle' }, 
    { name: 'rX', type: 'int',   initial: 0, caption: 'Rotation X:' },
    { name: 'rY', type: 'int',   initial: 0, caption: 'Rotation Y:' },
    { name: 'rZ', type: 'int',   initial: 0, caption: 'Rotation Z:' },
    { name: 'nbC',type: 'int', initial: 3, caption: 'Nb Colonnes (beige)' }, 
    { name: 'nbL',type: 'int', initial: 3, caption: 'Nb Lignes (orange)' },
    { name: 'eC', type: 'int', initial: 3, caption: 'Ep. Carton (mm)' },
    { name: 'mode',type: 'choice', initial: 1, caption:'Mode', captions:['Vue 3d','Vue 3d eclatee V', 'Vue 3d eclatee H', 'Vue 2d'], values:[30,31,32,2]},
    { name: 't1',  type: 'group', caption:'Gabarit'},
    { name: 'larg', type: 'number', initial: 210, caption: 'Largeur (mm)' }, 
    { name: 'haut', type: 'number', initial: 297, caption: 'Hauteur (mm)' }
  ];
}
function main(){

var r2d = [], v, tmp, i, b, tr, d, bz;
var nLignes = [], nColonnes = [], rL = [], rC = [], urL, urC;

// volume
v = center(true, scale(params.ech, rotate([params.rX, params.rY, params.rZ], volume())));
b = v.getBounds();
d = b[1].minus(b[0]);

for(i = 0.5; i< params.nbL; i++){ // lignes
  tr =rotate([90,0,0], faitLigne(i, v, params.nbL, params.eC));
  bz = tr.getBounds()[0].z;
  tr = union(vol2surf(tr, bz));
  tr= translate([0,bz +3, 0], rotate([-90,0,0], tr.extrude({offset:[0,0,params.eC]})));
  rL = rL.concat(tr);
}
urL = union(rL);

for(i = 0.5; i < params.nbC; i++){ // colonnes
  tr =rotate([0,90,0], faitColonne(i, v, params.nbC, params.eC));
  bz = tr.getBounds()[0].z;
  tmp = union(vol2surf(tr, bz));
  tr = translate([-bz, 0, 0], rotate([0,-90,0], tmp.extrude({offset:[0,0,params.eC]})));
  rC = rC.concat(tr);
}
urC = union(rC);

tmp = scission3d(urC.intersect(urL)); // encoches
var miH = [], miB = [], miT = [];
for(i = 0; i < tmp.length; i++){
  var tt = diviseVolume(tmp[i], d);
  miH.push(tt[1]);
  miB.push(tt[2]);
  miT.push(tt[0]);
}
var umiH = union(miH), umiB = union(miB);

if (params.mode == 2){ // rendu 2d
  var r = [], n, t2, t3, h;

  for(n = 0; n < rL.length; n++){
      t2 = rL[n].subtract(miT);
      t3 = t2.union(rL[n].intersect(umiH));
    r.push(translate([-params.larg * n, 0],
      square({size:[params.larg+4, params.haut+4], center:true})
      .subtract(square({size:[params.larg, params.haut], center:true}))));
    r.push(translate([-params.larg * n, 2], tourneEt2d(t3, [90, 0, 0])));
  }

  h = params.haut;
  for(n = 0; n < rC.length; n++){
    t2 = rC[n].subtract(miT);
    t3 = t2.union(rC[n].intersect(umiB));
    r.push(translate([-params.larg*n, h],
      square({size:[params.larg+4, params.haut+4], center:true})
      .subtract(square({size:[params.larg, params.haut], center:true}))));
    r.push(translate([-params.larg*n, h+2], tourneEt2d(t3, [0, -90, 0])));
  } 
 
  return r;
    
} else { // rendu 3d
  var ee, cv;
  if (params.mode == 30){
    ee = 0;
    cv = [1,0,0,0.2];
  } else {
    ee = 1.2;
    cv = "crimson";
  }

	if(params.mode == 31){
	  return [color("tan", translate([0, d.y * ee, d.z / 2], urC.subtract(miT).union(miB)))
		       ,color("orange", translate([0, -d.y * ee, d.z / 2], urL.subtract(miT).union(miH)))
		         ,color(cv, translate([0, 0, d.z / 2], v))
		  ];
	} else {
    return [color("tan", translate([d.x * ee, 0, d.z / 2], urC.subtract(miT).union(miB)))
           ,color("orange", translate([-d.x * ee, 0, d.z / 2], urL.subtract(miT).union(miH)))
           ,color(cv, translate([0, 0, d.z / 2], v))
      ];
  }
}
}

function tourneEt2d(vol, angle){
  var t = rotate(angle, vol);
  return union(vol2surf(t, t.getBounds()[1].z));
}

function faitColonne(i, V, nbC, ec){
	var vb = V.getBounds();
	var vd = vb[1].minus(vb[0]);
  var tNc1 = [[0, vb[0].x],[nbC, vb[1].x]];
  var b2 = lookup(i, tNc1);
  //var tmp = translate([b2 -ec, vb[0].y, -vd.z/2], cube({size:[ec, vd.y*3, vd.z*3], center:false}));
  var tmp = translate([b2 -ec, -500, -500], cube({size:[ec, 1000, 1000], center:false}));
  return V.intersect(tmp);
}

function faitLigne(i, V, nbL, ec){
	var vb = V.getBounds();
	var vd = vb[1].minus(vb[0]);
  var tNl1 = [[0, vb[0].y],[nbL, vb[1].y]];
  var b2 = lookup(i, tNl1);
  //var tmp = translate([vb[0].x, b2 -ec, -vd.z/2], cube({size:[vd.x*3, ec, vd.z*3], center:false}));
  var tmp = translate([-500, b2 -ec, -500], cube({size:[1000, ec, 1000], center:false}));
  return V.intersect(tmp);
}

function diviseVolume(vol, volD){
  var b = vol.getBounds();
  var d = b[1].minus(b[0]);
  var cDemi = cube({size:[d.x, d.y, d.z/2], center:false});
  var cTout = translate([b[0].x, b[0].y,-500], cube({size:[d.x, d.y, 1000], center:false}));    
  return [cTout,
          vol.intersect(translate(b[0], cDemi)),
          vol.intersect(translate([b[0].x, b[0].y, b[0].z + d.z/2], cDemi))
  	];
}

function sortNb		(E){ // returns E numerically sorted and deduplicated
	return E.sort(function(a, b) {return a-b}).filter(
	    function(item, pos, ary) {return !pos || item != ary[pos - 1]});
}

function compare3d	(v1, v2){ // returns true if V1 and V2 are at the same position
	return (v1.pos.x == v2.pos.x) && (v1.pos.y == v2.pos.y) && (v1.pos.z == v2.pos.z);
}

function compare2d			(v1, v2){ // returns true if V1 and V2 are at the same position
	return (v1.pos.x == v2.pos.x) && (v1.pos.y == v2.pos.y);
}

function scission2d			(geom){
	var i,j,i1,j1,ok,ti,tj,z,zz = [], P = geom.sides, RScission = [];

// construit table de correspondance entre Polygones (P)
// build polygons lookup table
	for (i = 0; i < P.length; i++) {
		ti = [P[i].vertex0, P[i].vertex1];
		z = [];
		for (j = 0; j < P.length; j++) {
			tj = [P[j].vertex0, P[j].vertex1];
			ok = false;
			for (i1 = 0; i1 < ti.length; i1++)
				for(j1 = 0; j1 < tj.length; j1++)
					{if (!ok)ok = compare2d(ti[i1], tj[j1]);}
			if (ok){z.push(parseInt(j));}
		}
		z = sortNb(z);
		zz.push({e:0, d:z});
		// console.log(i, z.toString());
	}

// regroupe les correspondances des polygones se touchant
// boucle ne s'arrêtant que quand deux passages retournent le même nb de polygones
// merge lookup data from linked polygons as long as possible
	ok = false;
	nElOk = 0;
	do {
		lnElOk = nElOk;
		nElOk = 0;
		for (i = 0; i < zz.length; i++) {
			if (zz[i].e >= 0) {
				nElOk++;
				for (j = 0; j < zz[i].d.length; j++) {
					a = zz[i].d[j];
					if (zz[a].e >= 0)
						if (i != a) {
							zz[i].d = sortNb(zz[i].d.concat(zz[a].d));
							zz[a].e = -1;
						}
				}
			}
		}
		ok = lnElOk == nElOk;
	}while (!ok);

// construit le tableau des CAG à retourner
// build array of CAG to return
	for (i = 0; i < zz.length; i++) {
		if (zz[i].e >= 0) {
			z = [];
			for (j = 0; j < zz[i].d.length; j++)
				z.push(P[zz[i].d[j]]);
			RScission.push(CAG.fromSides(z));
		}
	}

	return RScission;
}

function scission3d	(geom){
  var i,Pl, j,i1,j1,ok,ti,tj,z,zz = [], P, RScission, til, tjl, tii1, zzl, zzdl;
// construit table de correspondance entre Polygones (P)
// build polygons lookup table
  P = geom.toPolygons();
  RScission = [];
  Pl = P.length;
  for (i = 0; i < Pl; i++){
	ti = P[i].vertices;
	z = [];
	for (j = 0; j < Pl; j++){
      tj = P[j].vertices;
	  ok = false;
	  for (i1 = 0; i1 < ti.length; i1++){
	    tii1 = ti[i1];
		for(j1 = 0; j1 < tj.length; j1++)
		  if (!ok)ok = compare3d(tii1, tj[j1]);
	  }
	  if (ok)z.push(parseInt(j));
	}
	z = sortNb(z);
	zz.push({e:0, d:z});
  }

// regroupe les correspondances des polygones se touchant
// boucle ne s'arrêtant que quand deux passages retournent le même nb de polygones
// merge lookup data from linked polygons as long as possible
  ok = false;
  nElOk = 0;
  do {
    lnElOk = nElOk;
	nElOk = 0;
	for (i = 0; i < zz.length; i++){
	  if (zz[i].e >= 0) {
	    nElOk++;
		for (j = 0; j < zz[i].d.length; j++){
		  a = zz[i].d[j];
		  if (zz[a].e >= 0)
		    if (i != a) {
			  zz[i].d = sortNb(zz[i].d.concat(zz[a].d));
			  zz[a].e = -1;
			}
		}
	  }
	}
	ok = lnElOk == nElOk;
  }while (!ok);

// construit le tableau des CSG à retourner
// build array of CSG to return
  for (i = 0, zzl = zz.length; i < zzl; i++) {
    if (zz[i].e >= 0) {
	  z = [];
	  for (j = 0, zzdl = zz[i].d.length; j < zzdl; j++)
	    z.push(P[zz[i].d[j]]);
	  RScission.push(CSG.fromPolygons(z));
	}
  }

  return RScission;
}
// retourne la surface formee par le volume avec l'axe z (à 0)
function vol2surf(vol, orig = 0){
var n, pts, ok, P, i, pt;
let S = [];

for(n = 0; n < vol.polygons.length; n++){
  pts = [];
  P = vol.polygons[n];
  ok = true;
  for(i=0; (i < P.vertices.length) && ok; i++){
    pt = P.vertices[i].pos;
    if(Math.abs(pt.z - orig)< 0.05){
      pts.push([pt.x, pt.y]);
    } else {
      ok = false;
    }
  }
  if (ok){
    S.push(polygon(pts));
  }
}

return S;
}
/*
function poseAPlat(p){
  const v1 = p.vertices[0].pos, v2 = p.vertices[1].pos, v3 = p.vertices[2].pos;
  const tC = new CSG.Connector(v1, v2.minus(v1), p.plane.normal);
  const z0xC = new CSG.Connector([0, 0, 0], [0,v2.minus(v1).length(), 0.2], [0, 0, 1]);
  const tb = tC.getTransformationTo(z0xC, false, 0);
  let pp = (CSG.fromPolygons([p]).transform(tb)).polygons[0];

  let p2 = pp.vertices.map(v => new CSG.Vector2D(v.pos._x, v.pos._y));
  let poly2D = new CSG.Path2D(p2, true);
  return poly2D;
}*/

!-->
  </textarea>

  <textarea id="zc_dimensions" style="display:none;">
<!--
// Affiche un volume et ses dimensions (avec parametre echelle)

// parametres
function getParameterDefinitions() {
    return [
        { name: 'echelle', type: 'float', initial: 1, caption: 'Echelle?' }
    ];
}

function main(params) {
// Récupère le volume
var V = volume().scale(params.echelle);

// Calcule ses dimensions :
var b = V.getBounds(); // pts extrêmes du volume (plus petit et plus grand)
var d = b[1].minus(b[0]); // dimensions = différence entre ces deux points
var de = [d.x, d.y, d.z].map(Math.round);

// Affiche les dimensions
var r = [];

r.push(color("red", V)); // volume en rouge

// boite inscrite en cyan transparent (r:0, v:1, b:1, t:0.2)
r.push(color([0,1,1,0.2], cube([d.x, d.y, d.z]).translate(b[0])));

// dimensions
r.push(texte("larg. :"+ de[0].toString()+" mm").scale(0.5).translate([b[1].x,20,0]));
r.push(texte("long. :"+ de[1].toString()+" mm").scale(0.5).translate([b[1].x,0,0]));
r.push(texte("haut. :"+ de[2].toString()+" mm").scale(0.5).translate([b[1].x,-20,0]));

return r;
}

// Affiche une chaine de caractères
function texte(ch){
  let text = vectorText(ch);
  return csgFromSegments(text);
}

// transforme des segments en volume
function csgFromSegments (segments) {
  let output = [];
  segments.forEach(segment => output.push(
    rectangular_extrude(segment, { w:2, h:1 })
  ));
  return union(output);
}
!-->
  </textarea>
</body>

</html>
